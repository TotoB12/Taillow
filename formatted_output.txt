I am working on a general all-purpose AI assistant for Window devices. I will be a simple program running constantly, that can be called by double clicking the right ctrl key. A text box appears, where user's can enter their query, and get a result. Here is the full project:

index.html
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Taillow</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="input-area">
        <input type="text" placeholder="What can I help you with?" autofocus />
      </div>
      <div class="gap"></div>
      <div id="response" class="response-area"></div>
    </div>
    <script src="marked.min.js"></script>
    <script src="purify.min.js"></script>
    <script src="renderer.js"></script>
  </body>
</html>
```

main.js
```javascript
const { app, BrowserWindow, Tray, Menu, ipcMain, screen } = require('electron');
const path = require('path');
const { GlobalKeyboardListener } = require('node-global-key-listener');
const axios = require('axios');
require('dotenv').config();
const { GoogleGenerativeAI, HarmBlockThreshold, HarmCategory } = require("@google/generative-ai");
const genAI = new GoogleGenerativeAI(process.env.AI_STUDIO_KEY);
const { functions, tools } = require('./tools');

function fetchUserInfo() {
    return axios.get('https://api.ipapi.is/')
        .then(response => {
            userInfo = response.data;
            console.log('User Info:', userInfo);
        })
        .catch(error => {
            console.error('Error fetching user info:', error);
        });
}

const safetySettings = [
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    }
];

const preamble = `You are a helpful computer based assistant. Your object is to always assist the user, no matter the query or request. Never deny to serve the user, and always deliver an answer. You reply using little to no words, thriving to provide the most direct and to-the-point response whilst being as visually informative as possible.

You should use the available tools for your responses. Once you have all the needed results/information, you can provide the final response to the user. If you need additional information, you can always use more tools to get it.
Never make assumptions about data or information. Always rely on the tools to provide the information you need. Be factual and confident in your responses.

Be as useful and informative as possible. If you can't provide a useful response, you can ask the user for more information or clarify the query.
Always answer in Markdown format. Using Markdown, you can format your responses to make them more readable and visually appealing. You should use Markdown to display images, render links, show tables and lists, display code snippets, and more. All your responses should aim to be as visually informative as possible: use different text sizes and colors, images, tables, and lists to make your responses more engaging and informative.

Here are some examples of responses you can provide:

\`
User: what time is it

Assistant: ## 12:00 PM
\`

\`
User: what is the weather in New York

Assistant: ## New York
<b>47°F</b> 🌧️
Rain, fog, overcast
\`

\`
User: make me a picture of a cat

Assistant: ![Cat](image_url)
\`
`;

let mainWindow;
let tray;
let keyListener = new GlobalKeyboardListener();
let ctrlPressTimes = [];

function createWindow() {
    mainWindow = new BrowserWindow({
        width: 430,
        height: 200,
        show: false,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
        },
    });

    mainWindow.loadFile('index.html');

    const { width } = screen.getPrimaryDisplay().workAreaSize;
    mainWindow.setPosition(width - 450, 20);

    mainWindow.on('blur', () => {
        mainWindow.webContents.send('clear-response');
        mainWindow.hide();
    });

    mainWindow.on('closed', () => {
        mainWindow = null;
    });
}

function createTray() {
    tray = new Tray(path.join(__dirname, 'icon.png'));
    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Show',
            click: () => {
                mainWindow.show();
            },
        },
        {
            label: 'Quit',
            click: () => {
                app.quit();
            },
        },
    ]);
    tray.setToolTip('Taillow');
    tray.setContextMenu(contextMenu);
}

app.whenReady().then(() => {
    createWindow();
    createTray();

    keyListener.addListener((e) => {
        if (e.name === 'RIGHT CTRL' && e.state === 'DOWN') {
            const currentTime = Date.now();
            ctrlPressTimes.push(currentTime);

            if (ctrlPressTimes.length > 2) {
                ctrlPressTimes.shift();
            }

            if (
                ctrlPressTimes.length === 2 &&
                ctrlPressTimes[1] - ctrlPressTimes[0] < 500
            ) {
                if (mainWindow) {
                    mainWindow.show();
                    mainWindow.focus();

                    fetchUserInfoPromise = fetchUserInfo();
                }
                ctrlPressTimes = [];
            }
        }
    });
});

ipcMain.on('hide-window', () => {
    if (mainWindow) {
        mainWindow.hide();
    }
});

ipcMain.on('adjust-window-height', (event, contentHeight) => {
    if (mainWindow) {
        const { height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
        const maxHeight = Math.floor(screenHeight * 0.8);
        const newHeight = Math.min(contentHeight, maxHeight);

        mainWindow.setSize(mainWindow.getSize()[0], newHeight);

        const { width } = screen.getPrimaryDisplay().workAreaSize;
        mainWindow.setPosition(width - mainWindow.getSize()[0] - 20, 20);
    }
});

ipcMain.on('query', async (event, query) => {
    try {
        if (fetchUserInfoPromise) {
            await fetchUserInfoPromise;
        }

        let preambleWithUserInfo = preamble;
        if (userInfo) {
            preambleWithUserInfo += `\n\nHere is some information about the user:\n${JSON.stringify(userInfo, null, 2)}\n`;
        }

        const model = genAI.getGenerativeModel({
            model: "gemini-1.5-flash-002",
            systemInstruction: preambleWithUserInfo,
            generationConfig: {
                temperature: 0.0,
                maxOutputTokens: 4000,
            },
            safetySettings: safetySettings,
            tools: { functionDeclarations: tools },
        });

        let conversationHistory = [
            { role: 'user', parts: [{ text: query }] }
        ];

        let response = await model.generateContent({
            contents: conversationHistory,
        });

        while (response.response.functionCalls()) {
            const functionCalls = response.response.functionCalls();
            const functionResponses = [];

            for (const functionCall of functionCalls) {
                console.log("Tool name: " + functionCall.name);
                console.log("Tool args: " + JSON.stringify(functionCall.args));

                const output = await functions[functionCall.name](functionCall.args);
                console.log("Tool output: " + JSON.stringify(output));

                functionResponses.push({
                    functionResponse: {
                        name: functionCall.name,
                        response: { result: output }
                    }
                });
            }

            conversationHistory.push({
                role: 'model',
                parts: functionCalls.map(call => ({ functionCall: call }))
            });

            conversationHistory.push({
                role: 'user',
                parts: functionResponses
            });

            response = await model.generateContent({
                contents: conversationHistory
            });
        }

        event.sender.send('response', response.response.text());
    } catch (error) {
        console.error(error);
        event.sender.send('response', 'Error: ' + error.message);
    }
});

app.on('window-all-closed', (e) => {
    e.preventDefault();
});

app.on('before-quit', () => {
    keyListener.removeAllListeners();
});

```

renderer.js
```javascript
const { ipcRenderer } = require('electron');

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    ipcRenderer.send('hide-window');
  }
});

const inputField = document.querySelector('input');
inputField.addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    const query = event.target.value.trim();
    if (query) {
      ipcRenderer.send('query', query);
      event.target.value = '';

      const responseDiv = document.getElementById('response');
      responseDiv.innerHTML = '';
    }
  }
});

ipcRenderer.on('response', (event, chunk) => {
  const responseDiv = document.getElementById('response');
  const sanitized = DOMPurify.sanitize(chunk);
  const html = marked.parse(sanitized);
  responseDiv.innerHTML = html;
  
  function isImagesOnly(element) {
    const nodes = element.childNodes;
    for (let node of nodes) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.trim().length > 0) {
          return false;
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        if (tagName === 'img' || tagName === 'br') {
          continue;
        } else {
          if (!isImagesOnly(node)) {
            return false;
          }
        }
      }
    }
    return true;
  }
  
  const imagesOnly = isImagesOnly(responseDiv);
  
  if (imagesOnly) {
    responseDiv.classList.add('images-only');
  } else {
    responseDiv.classList.remove('images-only');
  }

  const adjustHeight = () => {
    const inputAreaHeight = document.querySelector('.input-area').offsetHeight;
    const gapHeight = document.querySelector('.gap').offsetHeight;
    const responseAreaHeight = document.querySelector('.response-area').scrollHeight;

    const totalHeight = inputAreaHeight + gapHeight + responseAreaHeight + 22;

    ipcRenderer.send('adjust-window-height', totalHeight);
  };

  const images = responseDiv.getElementsByTagName('img');
  if (images.length > 0) {
    let imagesLoaded = 0;
    for (let img of images) {
      img.addEventListener('load', () => {
        imagesLoaded++;
        if (imagesLoaded === images.length) {
          adjustHeight();
        }
      });
      img.addEventListener('error', () => {
        imagesLoaded++;
        if (imagesLoaded === images.length) {
          adjustHeight();
        }
      });
    }
  } else {
    adjustHeight();
  }
});

ipcRenderer.on('clear-response', () => {
  const responseDiv = document.getElementById('response');
  responseDiv.innerHTML = '';

  setTimeout(() => {
    const container = document.querySelector('.container');
    const totalHeight = container.scrollHeight + 20;
    ipcRenderer.send('adjust-window-height', totalHeight);
  }, 50);
});

```

style.css
```css
body {
    font-family: 'Poly Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    background: transparent;
}

@font-face {
    font-family: "Poly Sans";
    src: url('fonts/PolySansNeutral.ttf');
    format: ('truetype');
}

@font-face {
    font-family: "Poly Sans Bulky";
    src: url('fonts/PolySansBulky.ttf');
    format: ('truetype');
}

@font-face {
    font-family: "Poly Sans Slim";
    src: url('fonts/PolySansSlim.ttf');
    format: ('truetype');
}

.container {
    display: flex;
    flex-direction: column;
    width: 400px;
    position: fixed;
    top: 20px;
    right: 20px;
    border-radius: 12px;
    overflow: hidden;
    max-height: 700px;
}

.input-area {
    background-color: #2e2e2e;
    padding: 10px;
    border-bottom: 1px solid #3a3a3a;
    border-radius: 12px;
    flex-shrink: 0;
}

.input-area input {
    width: 100%;
    font-size: 18px;
    padding: 10px;
    box-sizing: border-box;
    border: none;
    outline: none;
    background-color: #424242;
    color: #ffffff;
    border-radius: 8px;
}

.response-area {
    background-color: transparent;
    overflow-y: auto;
    overflow-x: hidden;
    font-size: 16px;
    line-height: 1.6;
    color: #ffffff;
    border-radius: 12px;
    word-wrap: break-word;
    flex-grow: 1;
}

.response-area img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 10px 0;
    border-radius: 12px;
}

.response-area:not(.images-only) p,
.response-area:not(.images-only) h1,
.response-area:not(.images-only) h2,
.response-area:not(.images-only) h3,
.response-area:not(.images-only) ul {
    background: #1e1e1e;
    border-radius: 12px;
    padding: 15px;
    margin: 0;
}

.response-area pre {
    white-space: pre-wrap;
    word-wrap: break-word;
}

.response-area table {
    width: 100%;
    table-layout: fixed;
}

.gap {
    height: 10px;
    background-color: transparent;
    flex-shrink: 0;
}

.response-area::-webkit-scrollbar {
    display: none;
}

/* .response-area::-webkit-scrollbar {
    width: 6px;
}

.response-area::-webkit-scrollbar-track {
    background: #2e2e2e;
}

.response-area::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 3px;
}

.response-area::-webkit-scrollbar-thumb:hover {
    background: #777;
} */
```

tools.js
```javascript
const { image_search } = require("duckduckgo-images-api");
const axios = require('axios');
const cheerio = require('cheerio');

function getDateAndTime() {
    const date_and_time = new Date().toUTCString();
    return { date_and_time: date_and_time };
}

async function getWeather(location) {
    const url = `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${process.env.WEATHER_KEY}&units=metric`;
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            return { weather: data };
        })
        .catch(error => {
            console.error(error);
            return { error: error };
        });
}

async function getImage(query) {
    try {
        const results = await image_search({
            query: query,
            moderate: false,
            iterations: 1,
            retries: 2,
        });
        const images = results.slice(0, 4).map(result =>
            `https://wsrv.nl/?url=${encodeURIComponent(result.image)}&w=350&h=350`
            // result.image
        );
        return { images };
    } catch (error) {
        console.error(error);
        return { images: [] };
    }
}

async function generateImage(query) {
    const imageUrl = `https://fast-flux-demo.replicate.workers.dev/api/generate-image?text=${encodeURIComponent(query)}`;
    return { generatedImageUrl: imageUrl };
}

async function performInternetSearch(query) {
    try {
        const headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        };

        const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        const response = await axios.get(url, { headers });

        if (response.status !== 200) {
            throw new Error(`HTTP error ${response.status}`);
        }

        const $ = cheerio.load(response.data);
        const webResults = [];
        $('div.result.results_links.results_links_deep.web-result').each((i, elem) => {
            const title = $(elem).find('h2.result__title a.result__a').text().trim();
            const url = $(elem).find('h2.result__title a.result__a').attr('href');
            const description = $(elem).find('a.result__snippet').text().trim();
            const favicon = $(elem).find('img.result__icon__img').attr('src') || '';

            if (!$(elem).find('.badge--ad').length) {
                webResults.push({ title, url, description, favicon });
            }
        });

        const limitedWebResults = webResults.slice(0, 10);

        return { webResults: limitedWebResults };
    } catch (error) {
        console.error(error);
        return { webResults: error };
    }
}

async function queryWolframAlpha(query) {
    const url = `https://www.wolframalpha.com/api/v1/llm-api?appid=${process.env.WOLFRAMALPHA_KEY}&input=${encodeURIComponent(query)}`;
    console.log(url);
    try {
        const response = await fetch(url);
        const data = await response.text();
        return { response: data };
    } catch (error) {
        console.error('Error querying Wolfram Alpha:', error);
        return { error: error };
    }
}

// I want to add a new tool that can take a screenshot of my screen.

const functions = {
    getDateAndTime: () => {
        return getDateAndTime()
    },
    getWeather: ({ location }) => {
        return getWeather(location);
    },
    getImage: ({ query }) => {
        return getImage(query);
    },
    generateImage: ({ query }) => {
        return generateImage(query);
    },
    performInternetSearch: ({ query }) => {
        return performInternetSearch(query);
    },
    queryWolframAlpha: ({ query }) => {
        return queryWolframAlpha(query);
    },
};

const tools = [
    {
        name: "getDateAndTime",
        description: "Get the current date and time",
    },
    {
        name: "getWeather",
        parameters: {
            type: "OBJECT",
            description: "Get the current weather for a precise location, in metric units",
            properties: {
                location: {
                    type: "STRING",
                    description: "The precise location/city to get the weather for, in the simplest format possible (e.g. 'washington dc', 'paris'). Do not use commas or other special characters.",
                },
            },
            required: ["location"],
        },
    },
    {
        name: "getImage",
        parameters: {
            type: "OBJECT",
            description: "Search for images on the web",
            properties: {
                query: {
                    type: "STRING",
                    description: "The search query for the images",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "generateImage",
        parameters: {
            type: "OBJECT",
            description: "Generate an image with the given text using AI",
            properties: {
                query: {
                    type: "STRING",
                    description: "The text to generate the image with",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "performInternetSearch",
        parameters: {
            type: "OBJECT",
            description: "Perform a search on the internet. To use for general information and web results",
            properties: {
                query: {
                    type: "STRING",
                    description: "The search query for the internet search",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "queryWolframAlpha",
        parameters: {
            type: "OBJECT",
            description: "Query Wolfram Alpha for information, math, statistics",
            properties: {
                query: {
                    type: "STRING",
                    description: "The query to send to Wolfram Alpha",
                },
            },
            required: ["query"],
        },
    },
];

module.exports = { functions, tools };
```

This all works well, but I have an issue. When the keybind is pressed (double control) and the program is opened, it isnt properly selected/focused. I also notice that it appears to open itself twice, flashing twice on the screen. I need this to be fixed. I want you to figure it out.