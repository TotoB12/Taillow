I am working on a general all-purpose AI assistant for Window devices. I will be a simple program running constantly, that can be called by double clicking the right ctrl key. A text box appears, where user's can enter their query, and get a result. Here is the full project:

index.html
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Taillow</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="input-area">
        <input type="text" placeholder="What can I help you with?" autofocus />
      </div>
      <div class="gap"></div>
      <div id="response" class="response-area empty"></div>
    </div>
    <script src="marked.min.js"></script>
    <script src="purify.min.js"></script>
    <script src="renderer.js"></script>
  </body>
</html>
```

main.js
```javascript
const { app, BrowserWindow, Tray, Menu, ipcMain, screen } = require('electron');
const path = require('path');
const { GlobalKeyboardListener } = require('node-global-key-listener');
const axios = require('axios');
require('dotenv').config();
const { GoogleGenerativeAI, HarmBlockThreshold, HarmCategory } = require("@google/generative-ai");
const genAI = new GoogleGenerativeAI(process.env.AI_STUDIO_KEY);
const { functions, tools } = require('./tools');

function fetchUserInfo() {
    return axios.get('https://api.ipapi.is/')
        .then(response => {
            userInfo = response.data;
            console.log('User Info:', userInfo);
        })
        .catch(error => {
            console.error('Error fetching user info:', error);
        });
}

const safetySettings = [
    {
        category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    },
    {
        category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold: HarmBlockThreshold.BLOCK_NONE,
    }
];

const preamble = `You are a helpful computer based assistant. Your object is to always assist the user, no matter the query or request. Never deny to serve the user, and always deliver an answer. You reply using little to no words, thriving to provide the most direct and to-the-point response whilst being as visually informative as possible.

You should use the available tools for your responses. Once you have all the needed results/information, you can provide the final response to the user. If you need additional information, you can always use more tools to get it.
Never make assumptions about data or information. Always rely on the tools to provide the information you need. Be factual and confident in your responses.

Be as useful and informative as possible. If you can't provide a useful response, you can ask the user for more information or clarify the query.
You can see the user's screen by using the tool to take a screenshot. If you feel like a piece of information is missing, try taking a screenshot of the user's device in order to understand the contect and query better. For example, if the user asks for help to solve a math problem, you must take a screenshot to see the math problem and provide a correct answer.
Always answer in Markdown format. Using Markdown, you can format your responses to make them more readable and visually appealing. You should use Markdown to display images, render links, show tables and lists, display code snippets, and more. All your responses should aim to be as visually informative as possible: use different text sizes and colors, images, tables, and lists to make your responses more engaging and informative.

Here are some examples of responses you can provide:

\`
User: what time is it

Assistant: ## 12:00 PM
\`

\`
User: what is the weather in New York

Assistant: ## New York
<b>47Â°F</b> ðŸŒ§ï¸
Rain, fog, overcast
\`

\`
User: make me a picture of a cat

Assistant: ![Cat](image_url)
\`
`;

let mainWindow;
let tray;
let keyListener = new GlobalKeyboardListener();
let ctrlPressTimes = [];

function createWindow() {
    mainWindow = new BrowserWindow({
        width: 430,
        height: 200,
        show: false,
        frame: false,
        transparent: true,
        alwaysOnTop: true,
        skipTaskbar: true,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
        },
    });

    mainWindow.loadFile('index.html');

    const { width } = screen.getPrimaryDisplay().workAreaSize;
    mainWindow.setPosition(width - 450, 20);

    mainWindow.on('blur', () => {
        mainWindow.webContents.send('clear-response');
        mainWindow.hide();
    });

    mainWindow.on('closed', () => {
        mainWindow = null;
    });
}

function createTray() {
    tray = new Tray(path.join(__dirname, 'icon.png'));
    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Show',
            click: () => {
                mainWindow.show();
            },
        },
        {
            label: 'Quit',
            click: () => {
                app.quit();
            },
        },
    ]);
    tray.setToolTip('Taillow');
    tray.setContextMenu(contextMenu);
}

app.whenReady().then(() => {
    createWindow();
    createTray();

    keyListener.addListener((e) => {
        if (e.name === 'RIGHT CTRL' && e.state === 'DOWN') {
            const currentTime = Date.now();
            ctrlPressTimes.push(currentTime);

            if (ctrlPressTimes.length > 2) {
                ctrlPressTimes.shift();
            }

            if (
                ctrlPressTimes.length === 2 &&
                ctrlPressTimes[1] - ctrlPressTimes[0] < 500
            ) {
                if (mainWindow) {
                    mainWindow.show();
                    mainWindow.focus();

                    fetchUserInfoPromise = fetchUserInfo();
                }
                ctrlPressTimes = [];
            }
        }
    });
});

ipcMain.on('hide-window', () => {
    if (mainWindow) {
        mainWindow.hide();
    }
});

ipcMain.on('adjust-window-height', (event, contentHeight) => {
    if (mainWindow) {
        const { height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
        const maxHeight = Math.floor(screenHeight * 0.8);
        const newHeight = Math.min(contentHeight, maxHeight);

        mainWindow.setSize(mainWindow.getSize()[0], newHeight);

        const { width } = screen.getPrimaryDisplay().workAreaSize;
        mainWindow.setPosition(width - mainWindow.getSize()[0] - 20, 20);
    }
});

ipcMain.on('query', async (event, query) => {
    try {
        if (fetchUserInfoPromise) {
            await fetchUserInfoPromise;
        }

        let preambleWithUserInfo = preamble;
        if (userInfo) {
            preambleWithUserInfo += `\n\nHere is some information about the user:\n${JSON.stringify(userInfo, null, 2)}\n`;
        }

        const model = genAI.getGenerativeModel({
            model: "gemini-1.5-flash-002",
            systemInstruction: preambleWithUserInfo,
            generationConfig: {
                temperature: 0.0,
                maxOutputTokens: 4000,
            },
            safetySettings: safetySettings,
            tools: { functionDeclarations: tools },
        });

        let conversationHistory = [
            { role: 'user', parts: [{ text: query }] }
        ];

        let response = await model.generateContent({
            contents: conversationHistory,
        });

        while (response.response.functionCalls()) {
            const functionCalls = response.response.functionCalls();
            const functionResponses = [];

            for (const functionCall of functionCalls) {
                console.log("Tool name: " + functionCall.name);
                console.log("Tool args: " + JSON.stringify(functionCall.args));

                const output = await functions[functionCall.name](functionCall.args);
                console.log("Tool output: " + JSON.stringify(output));

                if (functionCall.name === 'takeScreenshot') {
                    functionResponses.push({
                        functionResponse: {
                            name: functionCall.name,
                            response: { success: "The screenshot has been added to the chat." }
                        }
                    });

                    conversationHistory.push({
                        role: 'user',
                        parts: [output]
                    });
                } else {
                    functionResponses.push({
                        functionResponse: {
                            name: functionCall.name,
                            response: output
                        }
                    });
                }
            }

            conversationHistory.push({
                role: 'model',
                parts: functionCalls.map(call => ({ functionCall: call }))
            });

            conversationHistory.push({
                role: 'user',
                parts: functionResponses
            });

            response = await model.generateContent({
                contents: conversationHistory
            });
        }

        event.sender.send('response', response.response.text());
    } catch (error) {
        console.error(error);
        event.sender.send('response', 'Error: ' + error.message);
    }
});

app.on('window-all-closed', (e) => {
    e.preventDefault();
});

app.on('before-quit', () => {
    keyListener.removeAllListeners();
});

```

renderer.js
```javascript
const { ipcRenderer } = require('electron');

document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    ipcRenderer.send('hide-window');
  }
});

const inputField = document.querySelector('input');
inputField.addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    const query = event.target.value.trim();
    if (query) {
      ipcRenderer.send('query', query);
      event.target.value = '';

      const responseDiv = document.getElementById('response');
      responseDiv.innerHTML = '';
    }
  }
});

ipcRenderer.on('response', (event, chunk) => {
  const responseDiv = document.getElementById('response');
  const sanitized = DOMPurify.sanitize(chunk);
  const html = marked.parse(sanitized);
  responseDiv.innerHTML = html;
  
  function isImagesOnly(element) {
    const nodes = element.childNodes;
    for (let node of nodes) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.trim().length > 0) {
          return false;
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        if (tagName === 'img' || tagName === 'br') {
          continue;
        } else {
          if (!isImagesOnly(node)) {
            return false;
          }
        }
      }
    }
    return true;
  }
  
  const imagesOnly = isImagesOnly(responseDiv);
  
  if (imagesOnly) {
    responseDiv.classList.add('images-only');
  } else {
    responseDiv.classList.remove('images-only');
  }

  if (responseDiv.innerHTML.trim().length === 0) {
    responseDiv.classList.add('empty');
  } else {
    responseDiv.classList.remove('empty');
  }

  const adjustHeight = () => {
    const inputAreaHeight = document.querySelector('.input-area').offsetHeight;
    const gapHeight = document.querySelector('.gap').offsetHeight;
    const responseAreaHeight = document.querySelector('.response-area').scrollHeight;

    const totalHeight = inputAreaHeight + gapHeight + responseAreaHeight + 22;

    ipcRenderer.send('adjust-window-height', totalHeight);
  };

  const images = responseDiv.getElementsByTagName('img');
  if (images.length > 0) {
    let imagesLoaded = 0;
    for (let img of images) {
      img.addEventListener('load', () => {
        imagesLoaded++;
        if (imagesLoaded === images.length) {
          adjustHeight();
        }
      });
      img.addEventListener('error', () => {
        imagesLoaded++;
        if (imagesLoaded === images.length) {
          adjustHeight();
        }
      });
    }
  } else {
    adjustHeight();
  }
});

ipcRenderer.on('clear-response', () => {
  const responseDiv = document.getElementById('response');
  responseDiv.innerHTML = '';
  responseDiv.classList.remove('images-only');
  responseDiv.classList.add('empty');

  setTimeout(() => {
    const container = document.querySelector('.container');
    const totalHeight = container.scrollHeight + 20;
    ipcRenderer.send('adjust-window-height', totalHeight);
  }, 50);
});

```

style.css
```css
body {
    font-family: 'Poly Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    background: transparent;
}

@font-face {
    font-family: "Poly Sans";
    src: url('fonts/PolySansNeutral.ttf');
    format: ('truetype');
}

@font-face {
    font-family: "Poly Sans Bulky";
    src: url('fonts/PolySansBulky.ttf');
    format: ('truetype');
}

@font-face {
    font-family: "Poly Sans Slim";
    src: url('fonts/PolySansSlim.ttf');
    format: ('truetype');
}

.container {
    display: flex;
    flex-direction: column;
    width: 400px;
    position: fixed;
    top: 20px;
    right: 20px;
    border-radius: 12px;
    overflow: hidden;
    max-height: 700px;
}

.input-area {
    background-color: #2e2e2e;
    padding: 10px;
    border-bottom: 1px solid #3a3a3a;
    border-radius: 12px;
    flex-shrink: 0;
}

.input-area input {
    width: 100%;
    font-size: 18px;
    padding: 10px;
    box-sizing: border-box;
    border: none;
    outline: none;
    background-color: #424242;
    color: #ffffff;
    border-radius: 8px;
}

.response-area {
    background-color: transparent;
    overflow-y: auto;
    overflow-x: hidden;
    font-size: 16px;
    line-height: 1.6;
    color: #ffffff;
    border-radius: 12px;
    word-wrap: break-word;
    flex-grow: 1;
}

.response-area img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 10px 0;
    border-radius: 12px;
}

.response-area:not(.images-only):not(.empty) {
    margin: 0;
    padding: 0px 15px;;
    border-radius: 12px;
    background: #1e1e1e;
}

.response-area pre {
    white-space: pre-wrap;
    word-wrap: break-word;
}

.response-area table {
    width: 100%;
    table-layout: fixed;
}

.gap {
    height: 10px;
    background-color: transparent;
    flex-shrink: 0;
}

.response-area::-webkit-scrollbar {
    display: none;
}

/* .response-area::-webkit-scrollbar {
    width: 6px;
}

.response-area::-webkit-scrollbar-track {
    background: #2e2e2e;
}

.response-area::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 3px;
}

.response-area::-webkit-scrollbar-thumb:hover {
    background: #777;
} */
```

tools.js
```javascript
const { image_search } = require("duckduckgo-images-api");
const screenshot = require('screenshot-desktop');
const fs = require("fs");
const axios = require('axios');
const cheerio = require('cheerio');

function base64ToGenerativePart(base64Data, mimeType) {
    return {
        inlineData: {
            data: base64Data,
            mimeType
        },
    };
}

function getDateAndTime() {
    const date_and_time = new Date().toISOString();
    return { date_and_time: date_and_time };
}

async function getWeather(location) {
    const url = `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${process.env.WEATHER_KEY}&units=metric`;
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            return { weather: data };
        })
        .catch(error => {
            console.error(error);
            return { error: error };
        });
}

async function getImage(query) {
    try {
        const results = await image_search({
            query: query,
            moderate: false,
            iterations: 1,
            retries: 2,
        });
        const images = results.slice(0, 4).map(result =>
            `https://wsrv.nl/?url=${encodeURIComponent(result.image)}&w=400&h=400`
            // result.image
        );
        return { images };
    } catch (error) {
        console.error(error);
        return { images: [] };
    }
}

async function generateImage(query) {
    const imageUrl = `https://fast-flux-demo.replicate.workers.dev/api/generate-image?text=${encodeURIComponent(query)}`;
    return { generatedImageUrl: imageUrl };
}

async function performInternetSearch(query) {
    try {
        const headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        };

        const url = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        const response = await axios.get(url, { headers });

        if (response.status !== 200) {
            throw new Error(`HTTP error ${response.status}`);
        }

        const $ = cheerio.load(response.data);
        const webResults = [];
        $('div.result.results_links.results_links_deep.web-result').each((i, elem) => {
            const title = $(elem).find('h2.result__title a.result__a').text().trim();
            const url = $(elem).find('h2.result__title a.result__a').attr('href');
            const description = $(elem).find('a.result__snippet').text().trim();
            const favicon = $(elem).find('img.result__icon__img').attr('src') || '';

            if (!$(elem).find('.badge--ad').length) {
                webResults.push({ title, url, description, favicon });
            }
        });

        const limitedWebResults = webResults.slice(0, 10);

        return { webResults: limitedWebResults };
    } catch (error) {
        console.error(error);
        return { webResults: error };
    }
}

async function queryWolframAlpha(query) {
    const url = `https://www.wolframalpha.com/api/v1/llm-api?appid=${process.env.WOLFRAMALPHA_KEY}&input=${encodeURIComponent(query)}`;
    console.log(url);
    try {
        const response = await fetch(url);
        const data = await response.text();
        return { response: data };
    } catch (error) {
        console.error('Error querying Wolfram Alpha:', error);
        return { error: error };
    }
}

async function takeScreenshot() {
    try {
        const img = await screenshot({ format: 'png' });
        const base64Image = img.toString('base64');
        const imagePart = base64ToGenerativePart(base64Image, 'image/png');
        return imagePart;
    } catch (error) {
        console.error('Error taking screenshot:', error);
        return { error: error.message };
    }
}

const functions = {
    getDateAndTime: () => {
        return getDateAndTime()
    },
    getWeather: ({ location }) => {
        return getWeather(location);
    },
    getImage: ({ query }) => {
        return getImage(query);
    },
    generateImage: ({ query }) => {
        return generateImage(query);
    },
    performInternetSearch: ({ query }) => {
        return performInternetSearch(query);
    },
    queryWolframAlpha: ({ query }) => {
        return queryWolframAlpha(query);
    },
    takeScreenshot: () => {
        return takeScreenshot();
    },
};

const tools = [
    {
        name: "getDateAndTime",
        description: "Get the current date and time",
    },
    {
        name: "getWeather",
        parameters: {
            type: "OBJECT",
            description: "Get the current weather for a precise location, in metric units",
            properties: {
                location: {
                    type: "STRING",
                    description: "The precise location/city to get the weather for, in the simplest format possible (e.g. 'washington dc', 'paris'). Do not use commas or other special characters.",
                },
            },
            required: ["location"],
        },
    },
    {
        name: "getImage",
        parameters: {
            type: "OBJECT",
            description: "Search for images on the web",
            properties: {
                query: {
                    type: "STRING",
                    description: "The search query for the images",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "generateImage",
        parameters: {
            type: "OBJECT",
            description: "Generate an image with the given text using AI",
            properties: {
                query: {
                    type: "STRING",
                    description: "The text to generate the image with",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "performInternetSearch",
        parameters: {
            type: "OBJECT",
            description: "Perform a search on the internet. To use for general information and web results",
            properties: {
                query: {
                    type: "STRING",
                    description: "The search query for the internet search",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "queryWolframAlpha",
        parameters: {
            type: "OBJECT",
            description: "Query Wolfram Alpha for information, math, statistics",
            properties: {
                query: {
                    type: "STRING",
                    description: "The query to send to Wolfram Alpha",
                },
            },
            required: ["query"],
        },
    },
    {
        name: "takeScreenshot",
        description: "Take a screenshot of the user's screen. Use this to see the user's screen and get needed information",
    },
];

module.exports = { functions, tools };
```

This all works well, but I want to add a new feature. The AI responses are composed using Markdown, but also LaTeX. The Markdown looks great with the current implementation, but I now also want to have the LaTeX look good. I found this documentation online:

```
Browser
KaTeX supports all major browsers, including Chrome, Safari, Firefox, Opera, Edge, and IE 11.

Starter template
<!DOCTYPE html>
<!-- KaTeX requires the use of the HTML5 doctype. Without it, KaTeX may not render properly -->
<html>
  <head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
  </head>
  ...
</html>
Loading as Global
If you include the katex.js directly, the katex object will be available as a global variable.

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.css" integrity="sha384-NFTC4wvyQKLwuJ8Ez9AvPNBv8zcC2XaQzXSMvtORKw28BdJbB2QE8Ka+OyrIHcQJ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.js" integrity="sha384-z9arB7KJHppq8kK9AESncXcQd/KXIMMPiCrAdxfFpp+5QU438lgBE7UFGbk+gljP" crossorigin="anonymous"></script>
KaTeX also provides minified versions:

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
The examples above load the script deferred using the defer attribute to speed up page rendering. The katex object will be available after DOMContentLoaded event is fired on the document. If you do not use defer, katex object will be available after the corresponding script tag.

If KaTeX is not used immediately or not critical, it is possible to load KaTeX asynchronously. Add async attribute to script and use rel="preload" and onload attribute on link.

You can prefetch KaTeX fonts to prevent FOUT or FOIT. Use Font Loading API or Web Font Loader:

<script>
  window.WebFontConfig = {
    custom: {
      families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
        'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
        'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
        'KaTeX_Size4', 'KaTeX_Typewriter'],
    },
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script>
You can also use rel="preload". Add <link rel="preload" href=(path to WOFF2 font) as="font" type="font/woff2" crossorigin="anonymous"> to head. Note that only few browsers support it and they all support WOFF2 so preloading WOFF2 fonts is enough.

See Google Web Fundamentals - Web Font Optimization for more detail.

Module Loaders
AMD
<script type="text/javascript">
    require([
        "https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.js",
    ], katex => {
        ...
    });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.css" integrity="sha384-NFTC4wvyQKLwuJ8Ez9AvPNBv8zcC2XaQzXSMvtORKw28BdJbB2QE8Ka+OyrIHcQJ" crossorigin="anonymous">
ECMAScript module
<script type="module" type="text/javascript">
    import katex from 'https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.mjs';
    ...
</script>
<script nomodule defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.js" integrity="sha384-z9arB7KJHppq8kK9AESncXcQd/KXIMMPiCrAdxfFpp+5QU438lgBE7UFGbk+gljP" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.css" integrity="sha384-NFTC4wvyQKLwuJ8Ez9AvPNBv8zcC2XaQzXSMvtORKw28BdJbB2QE8Ka+OyrIHcQJ" crossorigin="anonymous">
Use nomodule attribute to provide a fallback for older browsers that do not support ES modules.

Download & Host Things Yourself
Download a KaTeX release, copy katex.js, katex.css (or katex.min.js and katex.min.css to use minified versions), and the fonts directory, and include or import it like above.

You can also build from source. See Building from Source for more details.

Bundler
Use Node.js package managers to install KaTeX and import it in your project. Then bundle using bundlers like webpack or rollup.js. Note that you have to bundle the stylesheet (katex.css) or include it manually.
```

```
API
In-browser rendering
Call katex.render with a TeX expression and a DOM element to render into:

katex.render("c = \\pm\\sqrt{a^2 + b^2}", element, {
    throwOnError: false
});
To avoid escaping the backslash (double backslash), you can use String.raw (but beware that escaping ${ and backtick is not possible while using String.raw).

katex.render(String.raw`c = \pm\sqrt{a^2 + b^2}`, element, {
    throwOnError: false
});
Server-side rendering or rendering to a string
To generate HTML on the server or to generate an HTML string of the rendered math, you can use katex.renderToString:

var html = katex.renderToString("c = \\pm\\sqrt{a^2 + b^2}", {
    throwOnError: false
});
// '<span class="katex">...</span>'
Handling errors
The examples above use the throwOnError: false option, which renders invalid inputs as the TeX source code in red (by default), with the error message as hover text. Without this option, invalid LaTeX will cause a katex.ParseError exception to be thrown. See handling errors.

Configuring KaTeX
The last argument to katex.render and katex.renderToString can contain a variety of rendering options.

Persistent Macros
KaTeXâ€™s macro documentation tells the author that \gdef will create a macro that persists between KaTeX elements. In order to enable that persistence, you must create one shared macros object that you pass into every call to katex.render or katex.renderToString. (Do not create a fresh macros object for each call.)

For example, suppose that you have an array mathElements of DOM elements that contain math. Then you could write this code:

const macros = {};
for (let element of mathElements) {
    katex.render(element.textContent, element, {
        throwOnError: false,
        macros
    };
}
Notice that you create the macros object outside the loop. If an author uses \gdef, KaTeX will insert that macro definition into the macros object and since macros continues to exist between calls to katex.render, \gdef macros will persist between mathElements.

Security of Persistent Macros
Persistent macros can change the behavior of KaTeX (e.g. redefining standard commands), so for security, such a setup should be used only for multiple elements of common trust. For example, you might enable persistent macros within a message posted by a single user (by creating a macros object for that message), but you probably should not enable persistent macros across multiple messages posted by multiple users.
```

```
Auto-render Extension
This is an extension to automatically render all of the math inside of text. It searches all of the text nodes within a given element for the given delimiters, ignoring certain tags like <pre>, and renders the math in place.

Usage
This extension isn't part of KaTeX proper, so the script needs to be included (via a <script> tag) in the page along with KaTeX itself. For example, using a CDN:

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
Above, the defer attribute indicates that the script doesn't need to execute until the page has loaded, speeding up page rendering; and the onload attribute calls renderMathInElement once the auto-render script loads.

Alternatively, you can call the renderMathInElement when (or after) the DOMContentLoaded event fires on the document or in another deferred script. This approach is useful for specifying or computing options, or if you don't want to use a defer or onload attribute. For example:

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // â€¢ auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // â€¢ rendering keys, e.g.:
          throwOnError : false
        });
    });
</script>
ECMAScript module is also available:

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">
<script type="module">
    import renderMathInElement from "https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.mjs";
    renderMathInElement(document.body);
</script>
You can use nomodule attribute to provide a fallback for older browsers that do not support ES modules.

API
This extension exposes a single function, window.renderMathInElement, with the following API:

function renderMathInElement(elem, options)
elem is an HTML DOM element. The function will recursively search for text nodes inside this element and render the math in them.

options is an optional object argument that can have the same keys as the object passed to katex.render, in addition to five auto-render-specific keys:

delimiters: This is a list of delimiters to look for math, processed in the same order as the list. Each delimiter has three properties:

left: A string which starts the math expression (i.e. the left delimiter).
right: A string which ends the math expression (i.e. the right delimiter).
display: A boolean of whether the math in the expression should be rendered in display mode or not.
The default value is:

[
  {left: "$$", right: "$$", display: true},
  {left: "\\(", right: "\\)", display: false},
  {left: "\\begin{equation}", right: "\\end{equation}", display: true},
  {left: "\\begin{align}", right: "\\end{align}", display: true},
  {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
  {left: "\\begin{gather}", right: "\\end{gather}", display: true},
  {left: "\\begin{CD}", right: "\\end{CD}", display: true},
  {left: "\\[", right: "\\]", display: true}
]
If you want to add support for inline math via $...$, be sure to list it after $$, as in the following. (Because rules are processed in order, putting a $ rule first would catch $$ as an empty math expression.)

[
  {left: "$$", right: "$$", display: true},
  {left: "$", right: "$", display: false},
  {left: "\\(", right: "\\)", display: false},
  {left: "\\[", right: "\\]", display: true}
]
ignoredTags: This is a list of DOM node types to ignore when recursing through. The default value is ["script", "noscript", "style", "textarea", "pre", "code", "option"].

ignoredClasses: This is a list of DOM node class names to ignore when recursing through. By default, this value is not set.

errorCallback: A callback method returning a message and an error stack in case of an critical error during rendering. The default uses console.error.

preProcess: A callback function, (math: string) => string, used to process math expressions before rendering.

The displayMode property of the options object is ignored, and is instead taken from the display key of the corresponding entry in the delimiters key.

The same options.macros object (which defaults to an empty object {}) is passed into several calls to katex.render, so that consecutive equations can build up shared macros by \gdef.
```

What would be the best way to have this work? I want you to fully develop and implement this.

This all works well, but I have an issue. When the keybind is pressed (double control) and the program is opened, it isnt properly selected/focused: the window does show up on my screen, with the input field selected, but the window itself is not the selected program on my computer. I need this to be fixed. Is the window being reopened/generated every time? Should it be? What would be the best design? I want you to fully develop and implement a fix.